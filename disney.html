<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å¼•å…¥ Block 2 çš„è§†å£è®¾ç½®ï¼Œé€‚é…æ€§æ›´å¥½ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Disney - Magical </title>
    <!-- å¼•å…¥ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            height: 100dvh; /* è§£å†³ç§»åŠ¨ç«¯åœ°å€æ é—®é¢˜ */
            overflow: hidden;
            touch-action: none;
            cursor: none; /* æ²‰æµ¸æ¨¡å¼éšè—é¼ æ ‡ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            background-color: #000;
        }

        /* --- æ¥è‡ª Block 2 çš„èƒŒæ™¯å›¾å±‚è®¾ç½® --- */
        #bg-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            /* æ›¿æ¢ä¸ºæ–°çš„èƒŒæ™¯å›¾ */
            background: url('https://github.com/keatkeat0308/songphoto/blob/main/disney%20black.png?raw=true') no-repeat center bottom;
            background-size: 85% auto; /* æ‰‹æœºç«¯é»˜è®¤ */
            transition: filter 0.1s; /* ç”¨äºé—ªçƒæ•ˆæœ */
        }

        /* é’ˆå¯¹æ¨ªå±æˆ–å¤§å±å¹•çš„ä¼˜åŒ– */
        @media (min-aspect-ratio: 1/1) {
            #bg-layer {
                background-size: auto 60%; 
            }
        }

        /* é¼ æ ‡ç§»åŠ¨æ—¶æ˜¾ç¤ºå…‰æ ‡ */
        body:hover {
            cursor: default;
        }

        canvas#canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; 
            background: transparent; /* Canvas é€æ˜ */
        }
        
        /* æ‘„åƒå¤´ç”»ä¸­ç”»å®¹å™¨ */
        .camera-container {
            position: absolute;
            top: 30px;
            right: 10px;
            width: 140px; 
            height: 105px; 
            z-index: 20;    
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(0, 0, 0, 0.6); 
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            transition: opacity 0.5s, transform 0.3s;
            backdrop-filter: blur(4px);
        }
        
        .camera-container:hover {
            opacity: 1;
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
            cursor: default;
        }

        /* æ‘„åƒå¤´è§†é¢‘æµ */
        .input_video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            opacity: 0.5; 
        }

        /* æ‰‹åŠ¿è¯†åˆ«ç»˜åˆ¶å±‚ */
        #gesture_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 235, 205, 0.9);
            font-family: "Georgia", serif;
            font-size: 18px;
            letter-spacing: 3px;
            pointer-events: none;
            z-index: 10;
            text-align: center;
            transition: opacity 1s;
            text-shadow: 0 0 10px rgba(255, 200, 100, 0.5);
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status {
            position: absolute;
            top: 15px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: bold;
            z-index: 25;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: right;
            text-shadow: 0 1px 4px black;
        }

        /* æŒ‡å¼•æç¤º */
        #guide {
            position: absolute;
            top: 20px;
            left: 10px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            z-index: 20;
            pointer-events: none;
            line-height: 1.6;
            background: linear-gradient(to right, rgba(0,0,0,0.6), transparent);
            padding: 10px;
            border-radius: 4px;
            border-left: 2px solid rgba(255,255,255,0.2);
        }
        
        .key-hint {
            color: #ffaa55;
            font-weight: bold;
        }

        /* éŸ³ä¹æŒ‰é’®æ ·å¼ - ä¿æŒ Block 1 çš„æ·±è‰²æ²‰æµ¸é£æ ¼ */
        #musicBtn {
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            z-index: 30; 
            background-color: rgba(255, 105, 180, 0.2); 
            color: rgba(255, 255, 255, 0.9); 
            border: 1px solid rgba(255, 105, 180, 0.5); 
            border-radius: 30px; 
            padding: 8px 16px; 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 12px;
            font-weight: bold; 
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.2); 
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            outline: none;
            backdrop-filter: blur(2px);
            -webkit-tap-highlight-color: transparent; 
        }

        #musicBtn:hover, #musicBtn:active {
            background-color: rgba(255, 105, 180, 0.4);
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.5);
            transform: scale(1.05);
        }

        @keyframes pulse-btn {
            0% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 105, 180, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 105, 180, 0); }
        }
    </style>
</head>
<body>

    <!-- ç‹¬ç«‹çš„èƒŒæ™¯å±‚ (æ¥è‡ª Block 2) -->
    <div id="bg-layer"></div>

    <!-- éŸ³ä¹æ’­æ”¾å™¨ç»„ä»¶ -->
    <audio id="bgMusic" loop preload="auto">
        <source src="https://github.com/keatkeat0308/d/raw/refs/heads/main/Beauty%20and%20the%20beast.mp3.mp3" type="audio/mpeg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>

    <button id="musicBtn" onclick="toggleMusic()">
        ğŸµ BGM OFF
    </button>

    <!-- åŠ è½½ä¸çŠ¶æ€ -->
    <div id="loading">
        æ­£åœ¨è¿æ¥é­”æ³•ä¿¡å·...<br>
        <span style="font-size:25px; opacity:0.6; font-family:sans-serif; margin-top:8px; display:block;">
            Tap To Start<br>
            è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼Œæˆ–æŒ‰æ•°å­—é”® 1-5 æ§åˆ¶
        </span>
    </div>
    
    <div id="status">System Ready</div>
    
    <div id="guide">
        <span class="key-hint">5</span> Fingers / Step 1: <b> Fireworks 1</b><br>
        <span class="key-hint">4</span> Fingers / Step 2: <b> Fireworks 2</b><br>
        <span class="key-hint">3</span> Fingers / Step 3: <b> Fireworks 3</b><br>
        <span class="key-hint">2</span> Fingers / Step 4: <b> Fireworks 4</b><br>
        <span class="key-hint">1</span> Finger &nbsp;/ Step 5: <b> Finale</b><br>
        <span class="key-hint">Fist</span> (0) / Final Step: <b>Ending 2026</b>
    </div>

    <!-- å³ä¸‹è§’ç”»ä¸­ç”» -->
    <div class="camera-container">
        <video class="input_video" playsinline muted></video>
        <canvas id="gesture_canvas"></canvas>
    </div>
    
    <!-- ä¸»çƒŸèŠ±ç”»å¸ƒ -->
    <canvas id="canvas"></canvas>

    <script>
        // --- éŸ³ä¹æ§åˆ¶é€»è¾‘ (ä¿æŒ Block 1) ---
        const music = document.getElementById("bgMusic");
        const musicBtn = document.getElementById("musicBtn");
        let isMusicPlaying = false;

        music.volume = 0.5;

        function tryMobileAutoPlay() {
            if (music.paused) {
                const playPromise = music.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        updateMusicBtnState(true);
                        removeInteractionListeners();
                    })
                    .catch(error => {
                        console.log("ç”¨æˆ·äº¤äº’æœªå°±ç»ªæˆ–è¢«æ‹¦æˆªï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ç‚¹å‡»");
                    });
                }
            }
        }

        function addInteractionListeners() {
            document.addEventListener('touchstart', tryMobileAutoPlay, { passive: true, once: true });
            document.addEventListener('click', tryMobileAutoPlay, { once: true });
            document.addEventListener('keydown', tryMobileAutoPlay, { once: true });
        }

        function removeInteractionListeners() {
            document.removeEventListener('touchstart', tryMobileAutoPlay);
            document.removeEventListener('click', tryMobileAutoPlay);
            document.removeEventListener('keydown', tryMobileAutoPlay);
        }

        function toggleMusic() {
            removeInteractionListeners();

            if (isMusicPlaying) {
                music.pause();
                updateMusicBtnState(false);
            } else {
                const playPromise = music.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        updateMusicBtnState(true);
                    })
                    .catch(error => {
                        console.error("æ’­æ”¾å¤±è´¥:", error);
                        updateMusicBtnState(false);
                    });
                }
            }
        }

        function updateMusicBtnState(playing) {
            isMusicPlaying = playing;
            if (playing) {
                musicBtn.innerHTML = "ğŸµ BGM ON";
                musicBtn.style.backgroundColor = "rgba(255, 105, 180, 0.5)";
                musicBtn.style.boxShadow = "0 0 15px rgba(255, 105, 180, 0.6)";
                musicBtn.style.animation = "none"; 
            } else {
                musicBtn.innerHTML = "ğŸ”‡ BGM OFF";
                musicBtn.style.backgroundColor = "rgba(100, 100, 100, 0.3)";
                musicBtn.style.boxShadow = "none";
            }
        }

        // --- ä¸»ç¨‹åºé€»è¾‘ ---
        window.addEventListener('load', () => {
            const autoPlayPromise = music.play();
            if (autoPlayPromise !== undefined) {
                autoPlayPromise.then(_ => {
                    updateMusicBtnState(true);
                }).catch(error => {
                    console.log("æµè§ˆå™¨é˜»æŒ¡äº†è‡ªåŠ¨æ’­æ”¾ï¼Œå¯ç”¨ç‚¹å‡»è§¦å‘æ¨¡å¼ã€‚");
                    musicBtn.style.animation = "pulse-btn 2s infinite"; 
                    addInteractionListeners(); 
                });
            } else {
                 addInteractionListeners();
            }

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', { alpha: true }); // Block 2 éœ€è¦ alpha: true
            const loadingText = document.getElementById('loading');
            const statusText = document.getElementById('status');
            const bgLayer = document.getElementById('bg-layer'); // è·å–èƒŒæ™¯å±‚å¼•ç”¨

            const gestureCanvas = document.getElementById('gesture_canvas');
            const gestureCtx = gestureCanvas.getContext('2d');

            let width, height, scale;
            let particles = []; 
            let comets = [];    
            let smokes = [];
            let stars = []; 
            
            // --- æ ¸å¿ƒæ§åˆ¶å˜é‡ ---
            let castleFlash = 0; 
            let activeTimeouts = []; 
            let currentChapter = 0; 

            // --- ä»»åŠ¡è°ƒåº¦å™¨ ---
            function schedule(fn, delay) {
                const id = setTimeout(() => {
                    fn();
                }, delay);
                activeTimeouts.push(id);
                return id;
            }

            function stopCurrentChapter() {
                activeTimeouts.forEach(id => clearTimeout(id));
                activeTimeouts = [];
                comets = []; 
            }

            // --- åŸå ¡èµ„æº (ä½¿ç”¨ Block 2 çš„è™šæ‹Ÿå¸ƒå±€é€»è¾‘) ---
            let castleLayout = { width: 0, height: 0, x: 0, top: 0 };
            
            // åŠ è½½èƒŒæ™¯å›¾ä»¥è·å–å…¶çœŸå®æ¯”ä¾‹ï¼Œä»è€Œç²¾å‡†å®šä½çƒŸèŠ±å‘å°„ç‚¹
            const castleImgSource = new Image();
            castleImgSource.src = 'https://github.com/keatkeat0308/songphoto/blob/main/disney%20black.png?raw=true';
            castleImgSource.onload = () => {
                updateVirtualCastleLayout(); 
            };

            function updateVirtualCastleLayout() {
                // è®¡ç®—å½“å‰èƒŒæ™¯å›¾åœ¨ CSS ä¸­çš„æ˜¾ç¤ºå°ºå¯¸
                // é€»è¾‘å¿…é¡»ä¸ CSS çš„ background-size ä¿æŒä¸€è‡´ï¼Œæ‰èƒ½è®©å‘å°„ç‚¹å¯¹é½
                
                const screenAspect = width / height;
                const imgAspect = (castleImgSource.naturalWidth && castleImgSource.naturalHeight) 
                                  ? castleImgSource.naturalWidth / castleImgSource.naturalHeight 
                                  : 1.5; 

                if (screenAspect > 1.0) { 
                    // æ¨ªå±é€»è¾‘ (å‚è€ƒ CSS auto 60%)
                    castleLayout.height = height * 0.6;
                    castleLayout.width = castleLayout.height * imgAspect;
                } else {
                    // ç«–å±/ç§»åŠ¨ç«¯é€»è¾‘ (å‚è€ƒ CSS 85% auto)
                    castleLayout.width = width * 0.85;
                    castleLayout.height = castleLayout.width / imgAspect;
                }

                // åŸå ¡ä½äºåº•éƒ¨å±…ä¸­
                castleLayout.x = (width - castleLayout.width) / 2;
                castleLayout.top = height - castleLayout.height;
            }

            // --- èµ„æºé¢„æ¸²æŸ“ (ä¿æŒ Block 1) ---
            const starCanvas = document.createElement('canvas'); starCanvas.width = 32; starCanvas.height = 32;
            const sCtx = starCanvas.getContext('2d'); sCtx.fillStyle = '#FFFFFF'; sCtx.beginPath(); sCtx.arc(16, 16, 6, 0, Math.PI*2); sCtx.fill();
            const gradS = sCtx.createRadialGradient(16, 16, 6, 16, 16, 16); gradS.addColorStop(0, 'rgba(255, 220, 100, 0.8)'); gradS.addColorStop(1, 'rgba(255, 200, 50, 0)'); sCtx.fillStyle = gradS; sCtx.beginPath(); sCtx.arc(16, 16, 16, 0, Math.PI*2); sCtx.fill();

            const glowCanvas = document.createElement('canvas'); glowCanvas.width = 32; glowCanvas.height = 32;
            const gCtx = glowCanvas.getContext('2d'); const gradG = gCtx.createRadialGradient(16, 16, 0, 16, 16, 16); gradG.addColorStop(0, 'rgba(255, 255, 255, 1)'); gradG.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)'); gradG.addColorStop(1, 'rgba(255, 255, 255, 0)'); gCtx.fillStyle = gradG; gCtx.fillRect(0, 0, 32, 32);

            const smokeCanvas = document.createElement('canvas'); smokeCanvas.width = 128; smokeCanvas.height = 128;
            const smCtx = smokeCanvas.getContext('2d'); const smGrad = smCtx.createRadialGradient(64, 64, 0, 64, 64, 64); smGrad.addColorStop(0, 'rgba(160, 160, 170, 0.8)'); smGrad.addColorStop(0.3, 'rgba(120, 120, 130, 0.3)'); smGrad.addColorStop(1, 'rgba(80, 80, 90, 0)'); smCtx.fillStyle = smGrad; smCtx.fillRect(0, 0, 128, 128);

            const particleCache = {};
            const shapeColors = ['#FF3333', '#33FF33', '#3355FF', '#FFFF33', '#FF33FF', '#33FFFF', '#FFFFFF'];
            shapeColors.forEach(color => {
                const c = document.createElement('canvas'); c.width = 16; c.height = 16;
                const cx = c.getContext('2d'); const grad = cx.createRadialGradient(8, 8, 0, 8, 8, 8); grad.addColorStop(0, '#FFFFFF'); grad.addColorStop(0.4, color); grad.addColorStop(1, 'rgba(0,0,0,0)'); cx.fillStyle = grad; cx.beginPath(); cx.arc(8, 8, 8, 0, Math.PI*2); cx.fill();
                particleCache[color] = c;
            });

            function initStars() {
                stars = [];
                for (let i = 0; i < 40; i++) {
                    stars.push({ x: Math.random()*width, y: Math.random()*(height*0.65), size: Math.random()*2*scale, alpha: Math.random()*0.8, flickerSpeed: 0.01+Math.random()*0.03 });
                }
            }

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                gestureCanvas.width = 140; 
                gestureCanvas.height = 105;
                
                scale = Math.min(width, height) / 900; 
                scale = Math.max(0.6, scale); 
                updateVirtualCastleLayout(); // ä½¿ç”¨æ–°çš„è™šæ‹Ÿå¸ƒå±€è®¡ç®—
                initStars();
            }
            window.addEventListener('resize', resize);
            resize();

            const random = (min, max) => Math.random() * (max - min) + min;

            // --- ç²’å­ç±»å®šä¹‰ (ä¿æŒ Block 1) ---
            class Smoke { constructor(x, y) { this.x = x; this.y = y; this.vx = random(-0.25, 0.25) * scale; this.vy = random(-0.15, 0.15) * scale; this.size = random(20, 45) * scale; this.growth = random(0.15, 0.3) * scale; this.life = random(60, 100); this.maxLife = this.life; this.alphaStart = random(0.1, 0.25); } update() { this.x += this.vx; this.y += this.vy; this.size += this.growth; this.life--; return this.life > 0; } draw() { const progress = this.life / this.maxLife; const currentAlpha = this.alphaStart * Math.pow(progress, 2.0); if (currentAlpha > 0.005) { ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.globalAlpha = currentAlpha; const drawSize = this.size * 2; ctx.drawImage(smokeCanvas, this.x - drawSize/2, this.y - drawSize/2, drawSize, drawSize); ctx.restore(); } } }
            
            class Spark { constructor(x, y, vx, vy, isGlitter = false) { this.x = x; this.y = y; this.isGlitter = isGlitter; if (isGlitter) { this.vx = vx * 0.1 + random(-0.5, 0.5) * scale; this.vy = vy * 0.1 + random(-0.5, 0.5) * scale; this.friction = 0.9; this.gravity = 0.02 * scale; this.life = random(60, 100); this.maxLife = this.life; this.size = random(1, 2.5) * scale; this.flickerSpeed = random(0.3, 0.6); } else { this.vx = vx * 0.3 + random(-1.5, 1.5) * scale; this.vy = vy * 0.3 + random(-1.5, 1.5) * scale; this.friction = 0.95; this.gravity = 0.08 * scale; this.life = random(40, 80); this.maxLife = this.life; this.size = random(1, 3) * scale; this.flickerSpeed = random(0.1, 0.3); } this.flickerOffset = random(0, 100); } update() { this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life -= 1; return this.life > 0; } draw() { const flicker = Math.abs(Math.sin(this.life * this.flickerSpeed + this.flickerOffset)); const baseAlpha = this.life / this.maxLife; let finalAlpha, r, g, b; if (this.isGlitter) { finalAlpha = baseAlpha * (0.3 + flicker * 0.7); r = 255; g = 255; b = 255; } else { finalAlpha = baseAlpha * (0.3 + flicker * 0.7); r = 255; g = 220; b = 150; if (this.life < 20) { g = 150; b = 50; } } ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${finalAlpha})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
            
            class Comet { constructor(x, y, angle, speed, style = 'normal', color = null) { this.x = x; this.y = y; this.style = style; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.color = color; if (this.color) { this.friction = 0.99; this.gravity = 0.105 * scale; this.life = 140; this.headSize = 7 * scale; this.maxTrail = 20; } else { if (style === 'hover') { this.friction = 0.99; this.gravity = 0.09 * scale; this.life = 150; this.headSize = 9 * scale; this.maxTrail = 25; } else if (style === 'thin') { this.friction = 0.975; this.gravity = 0.1 * scale; this.life = 70; this.headSize = 3 * scale; this.maxTrail = 12; } else { this.friction = 0.99; this.gravity = 0.12 * scale; this.life = 100; this.headSize = 7 * scale; this.maxTrail = 20; } } this.trail = []; } update() { this.trail.push({x: this.x, y: this.y}); if(this.trail.length > this.maxTrail) this.trail.shift(); this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life -= 1; const emission = (this.style === 'thin') ? 1 : ((this.style === 'hover') ? 5 : 3); if (this.style !== 'thin' || Math.random() > 0.5) { for(let i=0; i<emission; i++) { const t = Math.random(); const last = this.trail[this.trail.length-1] || {x:this.x, y:this.y}; const lerpX = last.x + (this.x - last.x) * t; const lerpY = last.y + (this.y - last.y) * t; particles.push(new Spark(lerpX + random(-2,2), lerpY + random(-2,2), this.vx, this.vy, false)); } } if(this.style !== 'thin' && this.life % 2 === 0) smokes.push(new Smoke(this.x, this.y)); if (this.style === 'thin' && this.life % 4 === 0) { smokes.push(new Smoke(this.x, this.y)); } if (this.style === 'thin' && this.life === 0) { for(let k=0; k<8; k++) particles.push(new Spark(this.x, this.y, this.vx, this.vy, true)); } return this.life > 0; } draw() { if (this.color) { this.drawColored(); return; } for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const progress = i / this.trail.length; const size = this.headSize * 0.8 * progress; const alpha = progress * (this.style === 'hover' ? 0.95 : 0.8); ctx.beginPath(); ctx.arc(point.x, point.y, size, 0, Math.PI * 2); if(this.style === 'thin') ctx.fillStyle = `rgba(240, 245, 255, ${alpha * 0.8})`; else if(this.style === 'hover') ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; else ctx.fillStyle = `rgba(255, ${200 + progress * 55}, ${100 + progress * 155}, ${alpha})`; ctx.fill(); } ctx.beginPath(); ctx.arc(this.x, this.y, this.headSize, 0, Math.PI*2); ctx.fillStyle = '#fff'; const blur = (this.style === 'thin') ? 8 : ((this.style === 'hover') ? 30 : 20); ctx.shadowBlur = blur * scale; ctx.shadowColor = '#ffe'; ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.headSize * 0.6, 0, Math.PI*2); ctx.fill(); } drawColored() { for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const progress = i / this.trail.length; const size = this.headSize * 0.8 * progress; const alpha = progress * 0.8; ctx.beginPath(); ctx.arc(point.x, point.y, size, 0, Math.PI * 2); ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${alpha * 0.5})`; ctx.fill(); } ctx.beginPath(); ctx.arc(this.x, this.y, this.headSize * 2, 0, Math.PI*2); const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.headSize * 2); grad.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.8)`); grad.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`); ctx.fillStyle = grad; ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.headSize * 0.6, 0, Math.PI*2); ctx.fill(); } }
            
            class UrchinSpike { constructor(x, y, angle, speed, depthScale) { this.x = x; this.y = y; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.friction = 0.93; this.gravity = 0.01 * scale; this.life = 80; this.maxLife = this.life; this.depthScale = depthScale; this.history = []; this.beadSize = random(4.5, 7.5) * scale * depthScale; } update() { this.history.push({x: this.x, y: this.y}); if(this.history.length > 5) this.history.shift(); this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life--; if (this.life % 5 === 0 && Math.random() > 0.5) smokes.push(new Smoke(this.x, this.y)); if (this.life === 0) { createStaticOrb(this.x, this.y, this.depthScale, this.beadSize); return false; } return true; } draw() { if(this.history.length < 2) return; let alpha = 1; if (this.life < 10) alpha = this.life / 10; ctx.beginPath(); ctx.moveTo(this.history[0].x, this.history[0].y); ctx.lineTo(this.x, this.y); ctx.lineCap = 'round'; ctx.lineWidth = 1.5 * this.depthScale * scale; ctx.strokeStyle = `rgba(255, 230, 100, ${alpha})`; ctx.stroke(); const size = this.beadSize * alpha; ctx.drawImage(starCanvas, this.x - size, this.y - size, size * 2, size * 2); } }
            
            class StaticOrb { constructor(x, y, depthScale, startSize) { this.x = x; this.y = y; this.vx = random(-0.05, 0.05) * scale; this.vy = random(-0.05, 0.05) * scale; this.life = 90; this.maxLife = this.life; this.size = startSize * 1.6; this.twinkleOffset = random(0, 100); } update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; } draw() { const progress = this.life / this.maxLife; let flicker = 0.8 + 0.2 * Math.sin(this.life * 0.2 + this.twinkleOffset); if (progress < 0.3) flicker *= (progress / 0.3); const currentSize = this.size * flicker; ctx.drawImage(starCanvas, this.x - currentSize, this.y - currentSize, currentSize * 2, currentSize * 2); } }
            
            class WillowParticle { constructor(x, y, angle, speed, colorType, depthScale) { this.x = x; this.y = y; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.friction = 0.92; this.gravity = 0.09 * scale; this.life = random(180, 250); this.maxLife = this.life; this.trail = []; this.maxTrail = 20; this.colorType = colorType; this.depthScale = depthScale; this.width = (colorType === 'gold' ? 3.0 : 2.0) * scale * depthScale; } update() { this.trail.push({x: this.x, y: this.y}); if(this.trail.length > this.maxTrail) this.trail.shift(); this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life--; if(this.life % 8 === 0) smokes.push(new Smoke(this.x, this.y)); return this.life > 0; } draw() { if(this.trail.length < 2) return; const progress = this.life / this.maxLife; const alpha = Math.min(1, progress * 3); ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for(let i=1; i<this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y); ctx.lineTo(this.x, this.y); ctx.lineCap = 'round'; ctx.lineWidth = this.width * alpha; let strokeStyle; switch (this.colorType) { case 'gold': strokeStyle = `rgba(255, 240, 150, ${alpha})`; break; case 'red': strokeStyle = `rgba(255, 80, 80, ${alpha})`; break; case 'blue': strokeStyle = `rgba(80, 180, 255, ${alpha})`; break; case 'purple': strokeStyle = `rgba(220, 100, 255, ${alpha})`; break; case 'cyan': strokeStyle = `rgba(80, 255, 220, ${alpha})`; break; case 'lime': strokeStyle = `rgba(180, 255, 80, ${alpha})`; break; case 'magenta': strokeStyle = `rgba(255, 80, 220, ${alpha})`; break; case 'orange': strokeStyle = `rgba(255, 150, 50, ${alpha})`; break; case 'white': strokeStyle = `rgba(255, 255, 255, ${alpha})`; break; default: strokeStyle = `rgba(255, 240, 150, ${alpha})`; } ctx.strokeStyle = strokeStyle; ctx.stroke(); if (progress > 0.05) { const s = this.width * 2.5; ctx.drawImage(glowCanvas, this.x - s/2, this.y - s/2, s, s); } } }
            
            class Shell { constructor(x, y, targetX, targetY, type, depthScale) { this.x = x; this.y = y; this.targetY = targetY; this.type = type; this.depthScale = depthScale; const g = 0.2 * scale; const dy = y - targetY; const vy = Math.sqrt(2 * g * dy); const t = vy / g; const dx = targetX - x; const vx = dx / t; this.vx = vx; this.vy = -vy; this.gravity = g; this.isDead = false; } update() { this.vy += this.gravity; this.x += this.vx; this.y += this.vy; if (Math.random() > 0.7) smokes.push(new Smoke(this.x, this.y)); if (this.vy >= 0) { this.isDead = true; if(this.type === 'urchin') explodeUrchin(this.x, this.y, this.depthScale); else if(this.type === 'willow') explodeWillow(this.x, this.y, this.depthScale); for(let i=0; i<6; i++) smokes.push(new Smoke(this.x + random(-10,10), this.y + random(-10,10))); } return !this.isDead; } draw() { const size = 6 * scale * this.depthScale; ctx.drawImage(glowCanvas, this.x - size, this.y - size, size*2, size*2); ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); ctx.lineCap = 'round'; ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)'; ctx.lineWidth = 8 * scale; ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); ctx.strokeStyle = 'rgba(255, 255, 220, 0.95)'; ctx.lineWidth = 3 * scale; ctx.stroke(); } }
            
            class DigitShell { constructor(startX, startY, targetX, targetY, digitChar) { this.x = startX; this.y = startY; this.targetY = targetY; this.digitChar = digitChar; this.isDead = false; const g = 0.12 * scale; const h = startY - targetY; const vy = Math.sqrt(2 * g * h); const t = vy / g; const vx = (targetX - startX) / t; this.vx = vx; this.vy = -vy; this.gravity = g; this.trail = []; } update() { this.trail.push({x: this.x, y: this.y}); if(this.trail.length > 8) this.trail.shift(); this.vy += this.gravity; this.x += this.vx; this.y += this.vy; if (this.vy >= 0) { this.isDead = true; explodeDigit(this.x, this.y, this.digitChar); for(let i=0; i<3; i++) smokes.push(new Smoke(this.x, this.y)); } return !this.isDead; } draw() { for (let i = 0; i < this.trail.length; i++) { const point = this.trail[i]; const progress = i / this.trail.length; const size = 3 * scale * progress; ctx.beginPath(); ctx.arc(point.x, point.y, size, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${progress * 0.6})`; ctx.fill(); } ctx.beginPath(); ctx.arc(this.x, this.y, 4 * scale, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); } }
            
            class ShapeParticle { constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.img = particleCache[color] || particleCache['#FFFFFF']; const angle = random(0, Math.PI*2); const speed = random(0, 0.8) * scale; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.friction = 0.82; this.gravity = 0.003 * scale; this.life = 1000; this.maxLife = this.life; this.size = random(2, 3.5) * scale; this.blinkOffset = random(0, 100); } update() { this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; } draw() { const blink = Math.abs(Math.sin(Date.now() * 0.005 + this.blinkOffset)); const alpha = 0.6 + 0.4 * blink; ctx.globalAlpha = alpha; const s = this.size * 2.5; ctx.drawImage(this.img, this.x - s/2, this.y - s/2, s, s); ctx.globalAlpha = 1.0; } }

            // ================= é€»è¾‘æ§åˆ¶ =================
            function createStaticOrb(x, y, depthScale, size) { particles.push(new StaticOrb(x, y, depthScale, size)); }
            function explodeUrchin(x, y, depthScale) { const spikeCount = 120; for (let i = 0; i < spikeCount; i++) { const angle = (Math.PI * 2 / spikeCount) * i + random(-0.02, 0.02); const speed = random(10, 24) * scale * depthScale; particles.push(new UrchinSpike(x, y, angle, speed, depthScale)); } }
            function explodeWillow(x, y, depthScale) { const count = 100; const colors = ['gold', 'red', 'blue', 'purple', 'cyan', 'lime', 'magenta', 'orange', 'white']; for(let i=0; i<count; i++) { const angle = random(0, Math.PI*2); const speed = random(5, 22) * scale * depthScale; const color = colors[Math.floor(Math.random() * colors.length)]; particles.push(new WillowParticle(x, y, angle, speed, color, depthScale)); } for(let k=0; k<20; k++) { const ang = random(0, Math.PI*2); const spd = random(2, 8) * scale * depthScale; particles.push(new Spark(x, y, Math.cos(ang)*spd, Math.sin(ang)*spd, true)); } }
            
            function getShapePoints(char) { const pts = []; const addBezier = (p0, p1, p2, p3, steps) => { for(let i=0; i<=steps; i++) { const t = i/steps; const u = 1 - t; const tt = t * t; const uu = u * u; const uuu = uu * u; const ttt = tt * t; const x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x; const y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y; pts.push({x: x, y: y}); } }; const addEllipse = (cx, cy, rx, ry, startAng, endAng, steps) => { for(let i=0; i<=steps; i++) { const t = startAng + (endAng - startAng) * (i/steps); pts.push({x: cx + rx * Math.cos(t), y: cy + ry * Math.sin(t)}); } }; 
                if (char === '2') { addBezier({x: 0.2, y: 0.25}, {x: 0.2, y: -0.05}, {x: 0.8, y: -0.05}, {x: 0.8, y: 0.3}, 25); addBezier({x: 0.8, y: 0.3}, {x: 0.8, y: 0.45}, {x: 0.4, y: 0.7}, {x: 0.2, y: 0.9}, 25); addBezier({x: 0.2, y: 0.9}, {x: 0.5, y: 0.92}, {x: 0.8, y: 0.9}, {x: 0.85, y: 0.88}, 20); } 
                else if (char === '0') { addEllipse(0.5, 0.5, 0.3, 0.45, 0, Math.PI * 2, 45); } 
                else if (char === '6') { addBezier({x: 0.75, y: 0.1}, {x: 0.4, y: 0.0}, {x: 0.1, y: 0.4}, {x: 0.2, y: 0.7}, 35); addEllipse(0.5, 0.7, 0.3, 0.25, 0, Math.PI * 2, 40); } 
                return pts; 
            }
            function explodeDigit(cx, cy, char) { const s = 100 * scale; const pts = getShapePoints(char); pts.forEach(pt => { const px = cx + (pt.x - 0.5) * s; const py = cy + (pt.y - 0.5) * s; for(let k=0; k<3; k++) { const jitterX = random(-3, 3) * scale; const jitterY = random(-3, 3) * scale; const col = shapeColors[Math.floor(Math.random() * shapeColors.length)]; particles.push(new ShapeParticle(px + jitterX, py + jitterY, col)); } }); for(let i=0; i<15; i++) { particles.push(new Spark(cx, cy, 0, 0, true)); } }

            // --- è§¦å‘æŒ‡å®šç¯‡ç«  ---
            function playChapter(targetChapter) {
                // å…è®¸é¡ºåºæ’­æ”¾åˆ°ä¸‹ä¸€ç« ï¼Œæˆ–è€…åœ¨ç»“æŸç« (6)æˆ–é‡ç½®ç« (0)åè·³è½¬åˆ°ç¬¬1ç« 
                const isNext = targetChapter === currentChapter + 1;
                const isReset = (currentChapter === 6 || currentChapter === 0) && targetChapter === 1;

                if (isNext || isReset) {
                    stopCurrentChapter();
                    currentChapter = targetChapter;
                    statusText.innerText = "CHAPTER " + currentChapter + " ACTIVE";
                    statusText.style.color = "#FFD700";
                    
                    // æ‰§è¡Œç¯‡ç« é€»è¾‘
                    switch(currentChapter) {
                        case 1:
                            launchFanSequence();
                            schedule(() => launchCastleDiffusionSequence(), 480);
                            schedule(() => launchCastleSalvoSequence(), 1680);
                            schedule(() => launchThinCometSalvoSequence(), 2500);
                            break;
                        case 2:
                            launchSideComets();
                            schedule(() => launchUrchinSalvo(), 800);
                            break;
                        case 3:
                            launchWillowSalvo();
                            schedule(() => launchLowAccents(), 1600);
                            break;
                        case 4:
                            launchCastleCrossSequence();
                            schedule(() => launchOuterSalvoSequence(), 2200);
                            break;
                        case 5:
                            launchFinaleFan();
                            schedule(() => launchFinaleDiffusion(), 1500);
                            schedule(() => launchFinaleClimax(), 3000);
                            break;
                        case 6: // Ending
                            launchDigitFinale();
                            statusText.innerText = "FINALE";
                            setTimeout(() => { 
                                currentChapter = 0; 
                                statusText.innerText = "READY (Show 5)"; 
                                statusText.style.color = "rgba(255,255,255,0.6)";
                            }, 8000);
                            break;
                    }
                }
            }

            // --- ç¯‡ç«  1 å‡½æ•° (ä½¿ç”¨ Block 1 çš„é€»è¾‘) ---
            function launchFanSequence() { 
                const groundY = height - 20 * scale;
                const castleLeft = castleLayout.x + castleLayout.width * 0.22;
                const castleRight = castleLayout.x + castleLayout.width * 0.78;
                const count = 5; 
                const speed = 16.5 * scale; 
                const leftStart = -130*(Math.PI/180); const leftStep = (50*(Math.PI/180))/4; 
                const rightStart = -100*(Math.PI/180); const rightStep = (50*(Math.PI/180))/4; 
                for (let i = 0; i < count; i++) { 
                    schedule(() => { 
                        comets.push(new Comet(castleLeft, groundY, leftStart + leftStep*i, speed, 'normal')); 
                        comets.push(new Comet(castleRight, groundY, rightStart + rightStep*i, speed, 'normal')); 
                    }, i * 150); 
                } 
            }
            function launchCastleDiffusionSequence() { const cx = width/2; const cy = castleLayout.top + castleLayout.height * 0.2; const speed = 18*scale; const centerAngle = -Math.PI/2; const maxDeviation = 45*(Math.PI/180); const pairs = 4; const step = maxDeviation/pairs; comets.push(new Comet(cx, cy, centerAngle, speed, 'normal')); for (let i = 1; i <= pairs; i++) { schedule(() => { const deviation = step*i; comets.push(new Comet(cx, cy, centerAngle-deviation, speed, 'normal')); comets.push(new Comet(cx, cy, centerAngle+deviation, speed, 'normal')); }, i * 90); } }
            function launchCastleSalvoSequence() { const cx = width/2; const cy = castleLayout.top + castleLayout.height * 0.3; const baseSpeed = 20*scale; const centerAngle = -Math.PI/2; const step = (45*(Math.PI/180))/4; let angles = [centerAngle]; for (let i = 1; i <= 4; i++) { angles.push(centerAngle-step*i); angles.push(centerAngle+step*i); } angles.forEach(angle => { const spd = baseSpeed * random(0.95, 1.05); const ang = angle + random(-0.015, 0.015); schedule(() => { comets.push(new Comet(cx, cy, ang, spd, 'hover')); }, random(0, 30)); }); }
            function launchThinCometSalvoSequence() { 
                const groundY = height-20*scale; 
                const castleY = castleLayout.top + castleLayout.height * 0.4;
                const cx = width/2; 
                const points = []; 
                for(let i=0; i<5; i++) points.push({x: width * 0.05 + i*25*scale, y: groundY});
                for(let i=0; i<6; i++) points.push({x: cx - 100*scale + i*40*scale, y: castleY});
                for(let i=0; i<5; i++) points.push({x: width * 0.95 - i*25*scale, y: groundY});
                const baseSpeed = 19*scale; 
                points.forEach(pt => { const clusterCount = Math.floor(random(3, 5)); for(let k=0; k<clusterCount; k++) { const ang = -Math.PI/2 + random(-0.15, 0.15); const spd = baseSpeed * random(0.8, 1.2); schedule(() => { comets.push(new Comet(pt.x, pt.y, ang, spd, 'thin')); }, random(0, 150)); } }); 
            }
            
            // --- ç¯‡ç«  2 ---
            function launchSideComets() { const speed = 26 * scale; comets.push(new Comet(0, height, -60 * (Math.PI/180), speed, 'normal')); comets.push(new Comet(width, height, -120 * (Math.PI/180), speed, 'normal')); }
            function launchUrchinSalvo() { const cx = width/2; const groundY = height-20*scale; const castleH = castleLayout.top + castleLayout.height * 0.3; const clusters = [ { x: cx-350*scale, y: groundY, count: 2, depth: 0.9, targetH: height*0.4 }, { x: cx, y: castleH, count: 3, depth: 1.15, targetH: height*0.32 }, { x: cx+350*scale, y: groundY, count: 2, depth: 0.9, targetH: height*0.4 } ]; clusters.forEach(cluster => { for(let i=0; i<cluster.count; i++) { const offsetX = (i-(cluster.count-1)/2)*80*scale; schedule(() => { particles.push(new Shell(cluster.x+offsetX+random(-10,10), cluster.y, cluster.x+offsetX, cluster.targetH+random(-25,25), 'urchin', cluster.depth)); }, random(0, 300)); } }); }
            
            // --- ç¯‡ç«  3 ---
            function launchWillowSalvo() { const cx = width / 2; const castleTop = castleLayout.top + castleLayout.height * 0.1; const targetBaseY = height * 0.2; const spreadW = width * 0.7; const startX = cx - spreadW / 2; const stepX = spreadW / 6; for(let i=0; i<7; i++) { const targetX = startX + stepX * i; const targetY = targetBaseY + random(-50, 50) * scale; const depth = random(0.8, 1.2); schedule(() => { particles.push(new Shell(cx, castleTop, targetX, targetY, 'willow', depth)); }, i * 150 + random(0, 50)); } }
            function launchLowAccents() { const groundY = height - 20 * scale; const leftBase = width * 0.1; const rightBase = width * 0.9; const speed = 16 * scale; for(let i=0; i<5; i++) { schedule(() => { comets.push(new Comet(leftBase+random(-60,60)*scale, groundY, -Math.PI/2 + 0.3 + random(-0.15, 0.15), speed, 'thin')); }, i * 100); } for(let i=0; i<5; i++) { schedule(() => { comets.push(new Comet(rightBase+random(-60,60)*scale, groundY, -Math.PI/2 - 0.3 + random(-0.15, 0.15), speed, 'thin')); }, i * 100); } }
            
            // --- ç¯‡ç«  4 ---
            function launchCastleCrossSequence() { const cx = width / 2; const groundY = height - 20 * scale; const speed = 14.5 * scale; const offsets = [60, 100, 140, 180, 220].map(o => o * scale); const colors = [{r:255,g:50,b:50}, {r:50,g:150,b:255}, {r:255,g:200,b:50}, {r:200,g:50,b:255}, {r:50,g:255,b:100}]; for (let i = 0; i < 5; i++) { const col = colors[i % colors.length]; const leftOffset = offsets[i]; const rightOffset = offsets[i]; schedule(() => { comets.push(new Comet(cx - leftOffset, groundY, -75 * (Math.PI / 180), speed, 'normal', col)); }, i * 400); schedule(() => { comets.push(new Comet(cx + rightOffset, groundY, -105 * (Math.PI / 180), speed, 'normal', col)); }, i * 400 + 200); } }
            function launchOuterSalvoSequence() { const groundY = height - 20 * scale; const leftBase = width * 0.15; const rightBase = width * 0.85; const speed = 15.5 * scale; const colors = [{r:255,g:80,b:80}, {r:80,g:255,b:80}, {r:80,g:80,b:255}, {r:255,g:200,b:50}]; for(let i=0; i<4; i++) { const x = leftBase + (i - 1.5) * 35 * scale; comets.push(new Comet(x, groundY, -Math.PI/2 + random(-0.03, 0.03), speed, 'normal', colors[i])); } for(let i=0; i<4; i++) { const x = rightBase + (i - 1.5) * 35 * scale; comets.push(new Comet(x, groundY, -Math.PI/2 + random(-0.03, 0.03), speed, 'normal', colors[3-i])); } }
            
            // --- ç¯‡ç«  5 ---
            function launchFinaleFan() { 
                const groundY = height - 20 * scale;
                const launchLeft = castleLayout.x + castleLayout.width * 0.25;
                const launchRight = castleLayout.x + castleLayout.width * 0.75;
                const count = 7; const speed = 16 * scale; 
                const colors = [{r:255,g:50,b:50}, {r:50,g:150,b:255}, {r:255,g:200,b:50}, {r:200,g:50,b:255}, {r:50,g:255,b:100}, {r:255,g:100,b:200}, {r:100,g:255,b:255}]; 
                const leftStart = -120*(Math.PI/180); const leftStep = (40*(Math.PI/180))/6; 
                const rightStart = -100*(Math.PI/180); const rightStep = (40*(Math.PI/180))/6; 
                for (let i = 0; i < count; i++) { 
                    const col = colors[i % colors.length]; 
                    schedule(() => { 
                        comets.push(new Comet(launchLeft, groundY, leftStart + leftStep*i, speed, 'normal', col)); 
                        comets.push(new Comet(launchRight, groundY, rightStart + rightStep*i, speed, 'normal', col)); 
                    }, i * 100); 
                } 
            }
            function launchFinaleDiffusion() { const cx = width/2; const cy = castleLayout.top + castleLayout.height * 0.2; const speed = 15 * scale; const centerAngle = -Math.PI/2; const maxDeviation = 60*(Math.PI/180); const pairs = 6; const step = maxDeviation/pairs; const colors = [{r:255,g:80,b:80}, {r:80,g:255,b:80}, {r:80,g:80,b:255}, {r:255,g:200,b:50}]; comets.push(new Comet(cx, cy, centerAngle, speed, 'normal', colors[0])); for (let i = 1; i <= pairs; i++) { schedule(() => { const col = colors[i % colors.length]; const deviation = step*i; comets.push(new Comet(cx, cy, centerAngle-deviation, speed, 'normal', col)); comets.push(new Comet(cx, cy, centerAngle+deviation, speed, 'normal', col)); }, i * 80); } }
            function launchFinaleClimax() { const cx = width / 2; const castleTop = castleLayout.top; for(let i=0; i<5; i++) { schedule(() => { particles.push(new Shell(cx + random(-250, 250)*scale, castleTop, cx + random(-350, 350)*scale, height*0.25 + random(-30, 30)*scale, 'urchin', 1.3)); }, i * 800); } schedule(() => { for(let i=0; i<8; i++) { schedule(() => { const tx = width * 0.15 + (width * 0.7) * (i/7) + random(-50,50)*scale; particles.push(new Shell(cx, castleTop, tx, height*0.2 + random(-20, 20)*scale, 'willow', 1.4)); }, i * 500); } }, 4500); }

            // --- ç¯‡ç«  6 (Ending) ---
            function launchDigitFinale() {
                const cx = width / 2;
                const groundY = height - 20 * scale;
                const targetH = height * 0.35;
                const spacing = 130 * scale; 
                const digits = ['2', '0', '2', '6'];
                const totalW = (digits.length - 1) * spacing;
                const startX = cx - totalW / 2;
                digits.forEach((d, i) => {
                    const tx = startX + i * spacing;
                    const bx = cx + (i - 1.5) * (castleLayout.width * 0.4); 
                    for(let k=0; k<5; k++) { schedule(() => { particles.push(new DigitShell(bx + random(-15,15)*scale, groundY, tx, targetH, d)); }, k * 90); }
                });
            }

            function drawStars() {
                // æ˜Ÿæ˜Ÿç”¨ lighter æ¨¡å¼ç»˜åˆ¶
                ctx.globalCompositeOperation = 'lighter'; 
                stars.forEach(star => {
                    const flicker = 0.8 + 0.2 * Math.sin(Date.now() * star.flickerSpeed);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * flicker})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // --- é”®ç›˜æ§åˆ¶ (Fallback) ---
            window.addEventListener('keydown', (e) => {
                let target = -1;
                switch(e.key) {
                    case '1': target = 1; break;
                    case '2': target = 2; break;
                    case '3': target = 3; break;
                    case '4': target = 4; break;
                    case '5': target = 5; break;
                    case '0': target = 6; break;
                }
                if (target !== -1) {
                    loadingText.style.display = 'none'; // æŒ‰é”®æ—¶éšè—loading
                    triggerChapter(target);
                }
            });

            // ç»Ÿä¸€çš„è§¦å‘é€»è¾‘
            function triggerChapter(target) {
                if (target !== currentChapter) {
                    playChapter(target);
                }
            }

            // æ‰‹åŠ¿è¯†åˆ«è®¾ç½®
            const videoElement = document.getElementsByClassName('input_video')[0];
            let lastGestureTime = 0;
            const GESTURE_COOLDOWN = 1200; 
            
            function onResults(results) {
                if (loadingText.style.display !== 'none' && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    loadingText.style.display = 'none';
                }
                
                gestureCtx.save();
                gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
                
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(gestureCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 255, 0, 0.5)', lineWidth: 2});
                        drawLandmarks(gestureCtx, landmarks, {color: 'rgba(255, 0, 0, 0.5)', lineWidth: 1, radius: 2});
                        
                        const fingers = countFingers(landmarks);
                        const now = Date.now();

                        if (now - lastGestureTime > GESTURE_COOLDOWN) {
                            let target = -1;
                            if (fingers === 5) target = 1;
                            else if (fingers === 4) target = 2;
                            else if (fingers === 3) target = 3;
                            else if (fingers === 2) target = 4;
                            else if (fingers === 1) target = 5;
                            else if (fingers === 0) target = 6; // Fist

                            if (target !== -1) {
                                // æ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œä¸ºäº†é˜²æ­¢è¯¯è§¦ï¼Œæˆ‘ä»¬ä¸¥æ ¼éµå¾ª é¡ºåºé€»è¾‘
                                if (target === currentChapter + 1 || (currentChapter === 6 && target === 1) || (currentChapter === 0 && target === 1)) {
                                    triggerChapter(target);
                                    lastGestureTime = now;
                                }
                            }
                        }
                    }
                }
                gestureCtx.restore();
            }

            function countFingers(landmarks) {
                let count = 0;
                const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));
                // æ‹‡æŒ‡ (æ¯”è¾ƒæŒ‡å°–å’ŒæŒ‡å…³èŠ‚ç›¸å¯¹äºæ‰‹è…•çš„è·ç¦»ï¼Œè¿™ç§ç®€æ˜“ç®—æ³•å¯¹äºæ­£é¢æ‰‹æŒæ¯”è¾ƒå‡†)
                // æ›´ç¨³å¥çš„æ‹‡æŒ‡ï¼šæ¯”è¾ƒæŒ‡å°–xåæ ‡å’ŒIPå…³èŠ‚xåæ ‡ï¼ˆæ ¹æ®å·¦å³æ‰‹ä¸åŒï¼‰ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
                if (dist(landmarks[4], landmarks[0]) > dist(landmarks[3], landmarks[0]) * 1.1) count++;
                
                // å…¶ä»–å››æŒ‡ï¼šæ¯”è¾ƒæŒ‡å°–å’ŒæŒ‡æ ¹åˆ°æ‰‹è…•çš„è·ç¦»
                if (dist(landmarks[8], landmarks[0]) > dist(landmarks[6], landmarks[0]) * 1.1) count++; 
                if (dist(landmarks[12], landmarks[0]) > dist(landmarks[10], landmarks[0]) * 1.1) count++; 
                if (dist(landmarks[16], landmarks[0]) > dist(landmarks[14], landmarks[0]) * 1.1) count++; 
                if (dist(landmarks[20], landmarks[0]) > dist(landmarks[18], landmarks[0]) * 1.1) count++; 
                return count;
            }

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            // å°è¯•å¯åŠ¨æ‘„åƒå¤´ï¼Œä½†ä¸é˜»å¡ä¸»çº¿ç¨‹
            camera.start().catch(e => {
                console.log("Camera failed to start, use keyboard fallback.", e);
                loadingText.innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·ä½¿ç”¨æ•°å­—é”® 1-5 æ§åˆ¶çƒŸèŠ±";
            });

            // ä¸»å¾ªç¯
            function loop() {
                requestAnimationFrame(loop);

                // è®¡ç®—äº®åº¦ (ç”¨äºæ§åˆ¶èƒŒæ™¯å›¾çš„é—ªçƒ)
                const targetFlash = (particles.length * 0.0005) + (comets.length * 0.005);
                castleFlash += (targetFlash - castleFlash) * 0.1;
                
                // å°†é—ªçƒåº”ç”¨åˆ°èƒŒæ™¯ CSS ä¸Š
                if (bgLayer) {
                    const flashIntensity = Math.min(castleFlash * 2.5, 1.2);
                    bgLayer.style.filter = `brightness(${1.0 + flashIntensity})`;
                }

                // èƒŒæ™¯ (è½»å¾®æ‹–å°¾æ•ˆæœ - ä½¿ç”¨ destination-out æ¸…é™¤ Canvas ä½¿å¾—ä¸‹å±‚èƒŒæ™¯å›¾å¯è§)
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
                ctx.fillRect(0, 0, width, height);

                drawStars();
                // æ³¨æ„ï¼šä¸å†è°ƒç”¨ drawCastle()ï¼Œå› ä¸ºç°åœ¨æ˜¯èƒŒæ™¯å›¾

                ctx.globalCompositeOperation = 'lighter'; 
                let sIndex = smokes.length; while(sIndex--) { if(!smokes[sIndex].update()) smokes.splice(sIndex, 1); else smokes[sIndex].draw(); }
                
                ctx.globalCompositeOperation = 'lighter'; 
                let pIndex = particles.length; while(pIndex--) { if(!particles[pIndex].update()) particles.splice(pIndex, 1); else particles[pIndex].draw(); }
                let cIndex = comets.length; while(cIndex--) { if(!comets[cIndex].update()) comets.splice(cIndex, 1); else comets[cIndex].draw(); }
            }

            loop();
        });
    </script>
</body>
</html>